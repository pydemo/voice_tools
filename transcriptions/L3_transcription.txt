 In this lesson, you will learn about the agent reflection framework. And leverage its power to create a high-quality blog post. You will learn how to use the nested chat conversation pattern to realize a sophisticated reflection process. You will get to build a system where a set of reviewer agents is nested within a critic agent as the inner monologue to reflect on the blog post written by a writer agent. Let's make the magic happen. In this lesson, let's consider a blog post writing task. Let's say we want to write a concise but engaging blog post about deeplearning.ai, and I want to make sure the blog post is within 100 words. So with what we have learned in the first lesson, I guess the first thing that comes into your mind is to construct a writer agent to do the task. And that is true. So let's do that real quick. So here we could just import autogen and construct a model-based assistant agent as the writer. Here, of course, you could just let the writer agent to do the writing by calling this generateReply function and provide the task as the input. And then you could check this result from this generateReply function. All right, now we have a blog post about deeplearning.ai. This is good, but we want to make it even better. One idea here is to use reflection, which is one of the notable and effective agentic design patterns. One way to realize reflection is to involve another agent to reflect on the work and help improve it. Following this idea, let's now create a critic agent to reflect on the work of the writer agent. So similarly, let's use the Assistant Agent class from AutoGen and create this large-language model-based agent. And here we can prompt this critic to investigate the writing of the writer and provide feedback. And with these two agents, we will be able to initiate a chat between these two agents to have a back-and-forth conversation between the critic and the writer. So here you can see that the writer gave a first version of the blog post, and then the critic provided some feedback, and then the writer gave another version of the blog post. From this result, we could see that this agent is reflecting on the work and making suggestions. And this is good, but the suggestions are still kind of general. In many cases, we may want to realize an even more complex reflection workflow as the inner monologue of the critic agent. For example, we may want to ensure the critic agent to provide criticism regarding certain aspects of the work. For example, whether the content will rank well in search engine, whether it will attract organic traffic, whether it has legal problems and ethical problems, etc. Let's now see how we could use message chat to handle all this. Message chat is effectively a chat registered as the inner monologue of an agent. So let's first define the chat. In this specific blog post writing task, let's say we want to create a bunch of reviewers within the critic agent to carefully examine different aspects of the writing. So the first agent we want to include is an SEO agent. This reviewer is responsible for optimizing the content for search engine to ensure that it ranks well and attracts organic traffic. And we realized that by setting the system message of this reviewer agent. And the second reviewer is a legal reviewer. We prompted to be responsible for ensuring the content is legally compliant. The other reviewer agent we want to include is the ethics reviewer. This reviewer is responsible for ensuring the content is ethically sound and free from any potential ethical issues. And note that in all these three reviewer agents, we are instructing it to concept suggestions And we also want the reviewers to begin the review with the role, so that later we can further aggregate the reviews from these reviewers to a final review. Finally, mimicking how a real reviewing process works, we may also want a meta-reviewer to aggregate all the reviews and give final suggestions. To do that, here we create a meta-reviewer, and the meta-reviewer will aggregate all the reviews from the reviewers. The next step is to define the chats to be registered. Here we further use the sequential chat conversation pattern learned in the last lesson to construct a series of chats between the critic and the reviewers. Here we are effectively having a list of four chats. Each one of them involve a a particular reviewer as a recipient. Later, we will register this chat list to the critic agent. So the critic agent will be used as a sender by default, and we don't need to further specify the sender here. And also, for the first three chat sessions, we also use a large-language model to do summary following the desired format. So that's why the summary method is said to be reflection with LLM, and we provide a summary prompt so that each of these reviewers could return the review in a JSON format, which includes a field of reviewer and a field of review. And in all of these chat sessions, we set the max turns to be one. One other thing worth mentioning is that we need to set up the initial message properly so that the nested reviewers can get the content to be reviewed on. One commonly used way to do that is to get the content from the summary of the outer chat session. That's why we define the initial message to be a function, reflection message. So this function's responsibility is to get the summary from the agents in the outer chat session. And here we are calling the chat messages for summary as the initial message. Finally, we could register the review chat to the critic agent as a message chat. And in this register message chat function, we also set the trigger to be the writer. By doing so, whenever the critic agent receives a message from this writer agent, it will automatically route the message to this message chat session for careful reflection. And after this registration step, we can now initiate the chat between the critic and the writer. Note that this step is basically the same as what we did when we do a reflection between the critic and the writer agent. And the difference is that this time we are registering this next chat session on top of this critique to do more careful reflection. And here we kick off the chat session. As we can see, the first step is for the writer to generate a first version of the blog post. So basically this is the same as we have seen before. And here, instead of directly giving feedback, the critic agent will route the message to the message chat. Here for example, you can see that we are starting a new chat between the critic agent and the SEO reviewer. And the SEO reviewer will investigate this content and give suggestions on how to optimize the content for search engine by incorporating relevant keywords such as AI courses, deeplearning.ai, and join. And then we move on to the legal reviewer. And the legal reviewer will investigate potential legal risks. For example, this legal reviewer is suggesting to review to investigate this title. And now we move on to the ethics reviewer. After investigating on the blog post, the ethics reviewer investigates potential ethics issues and concludes that no modification or concern is raised regarding ethical implications. And finally, we move on to the meta reviewer. So basically the meta reviewer will investigate all the reviews we received from the previous reviewers. And because we have instructed the chat sessions to summarize the chat, each of these chats, in this nice JSON format, so we have these nice reviews and reviewers. And finally, meta-reviewer will give the final aggregated suggestion through the critic agent to the writer agent. And after this writer agent receives the suggestion from this critic agent, it will refine the blog post accordingly. So this is basically how we leverage message chat to realize reflection, especially careful reflection with a dedicated workflow. And now let's further check the result from this chat session. Here we are calling the summary to check the result. And here you can see that it is returning the final refined version of the blog post. Feel free to pause here and try your own task. For example, you can as an agent write a blog post on a topic that you are interested in. Alright, in this lesson, we have learned how to realize the reflection agentic design pattern with NestedChat. In the next lesson, we will learn how to further leverage tool using in NestedChat to further level up the agentic design patterns. Stay tuned!